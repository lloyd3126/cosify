# flows 整合計劃：原子化任務清單

說明：以下按「最小可交付單元」拆解，並依依賴順序分段，方便逐步 PR 與驗收；所有文字以中文為準，實作時再補英文註解。

## A. 資料與載入層
- [ ] A1 建立根目錄 `flows.json`（由 example.json 改名），結構：`{ flows: Record<flowId, Flow> }`。
- [ ] A2 Flow 結構擴充 `metadata` 欄位：`{ description?: string; thumbnail?: string; visibility?: "public" | "private" }`。
- [ ] A3 建立 server 端讀取與 parse 工具（僅讀本機檔；失敗時提供明確錯誤）。
- [ ] A4 以 `slug` 建立索引（Map<slug, flowId>），找不到回 404。
- [ ] A5 實作 Flow 結構驗證（步驟 type、referenceImgs 合法性：存在且引用先前步驟）。

## B. 路由與頁面
- [ ] B1 新增公開列表頁 `/flows`：顯示 `metadata.visibility === "public"` 的 flows（name、description、thumbnail、連結）。
- [ ] B2 新增受保護頁 `/flows/[slug]`：Server Component 驗證登入，未登入顯示提示或導至登入。
- [ ] B3 新增歷史頁 `/flows/[slug]/history`：需登入，只顯示登入者自己的 run 歷史，可刪除 run。
- [ ] B4 對於不支援的步驟 type，頁面載入時整個 flow 中止並顯示錯誤（不渲染其餘步驟）。

## C. 執行與歷史（R2 與 DB）
- [ ] C1 產出圖 R2 命名規則統一：`flows/{slug}/{userId}/{runId}/{stepId}.png`。
- [ ] C2 上傳步驟（uploader）之原始檔亦保存至 R2 與 DB（支援重整與可重現）：`flows/{slug}/{userId}/{runId}/{uploaderStepId}.png`。
- [ ] C3 DB 新增表 `flow_runs`：`runId (pk), userId, slug, status, error, createdAt, updatedAt`。
- [ ] C4 DB 新增表 `flow_run_steps`：`runId+stepId (pk), r2Key, durationMs, createdAt, error? , model?, prompt?, temperature?`。
- [ ] C5 新增 API 刪除歷史：刪 DB 與對應 R2 物件（手動刪除，無自動清理）。

## D. API 設計
- [ ] D1 `POST /api/flows/[slug]/run`：建立新 run（需登入）；回傳 `{ runId }`。
- [ ] D2 `POST /api/flows/[slug]/steps/[stepId]/generate`：通用生成端點。
  - 請求包含：`runId, model, prompt, temperature, inputs[] (Files 或 R2 keys)`。
  - 嚴格以 JSON 權威（model/prompt/temperature），後端不覆蓋。
  - 伺服器校驗 referenceImgs 與順序、inputs 數量、run 歸屬與 slug 一致性。
  - 成功：寫入 R2（命名規則），落 DB（flow_run_steps），回 `{ key, runId, stepId }`。
  - 失敗：回 400/422/500，訊息中文。
- [ ] D3 `GET /api/flows/[slug]/history`：列出當前使用者的 runs 與每步 r2Key。
- [ ] D4 `DELETE /api/flows/[slug]/history/[runId]`：刪除指定 run（含 DB 與 R2）。

## E. 前端互動（`/flows/[slug]`）
- [ ] E1 頁面初始化：讀取 `flows.json` 該 slug 的 flow，先做結構驗證；若有不支援 type 或引用不合法 → 顯示錯誤並中止。
- [ ] E2 建立 run（呼叫 D1），保存 `runId` 於前端狀態。
- [ ] E3 type=uploader：
  - 選檔後立即上傳至 R2（以 runId 命名規則），並記錄於 DB（flow_run_steps），避免重整遺失。
  - 上傳成功後更新前端狀態（該步已具備輸入）。
- [ ] E4 type=imgGenerator：
  - 僅使用 flow JSON 的 `model/prompt/temperature`。
  - 依 `referenceImgs` 順序組合 inputs：
    - 指向 uploader → 用該步對應的 R2 key；
    - 指向先前 imgGenerator → 用該步的 R2 key；
  - 呼叫 D2 生成並回寫結果，更新畫面與 DB。
- [ ] E5 錯誤顯示：
  - 結構/順序錯誤 → 頁面主視圖顯示錯誤卡片。
  - 執行錯誤 → toast + 步驟卡片內錯誤狀態（中文）。
- [ ] E6 下載與重跑：
  - 下載直接 GET `/api/r2/{key}`。
  - 重跑：建立新 run（重新呼叫 D1），重走步驟，形成新的歷史版本。

## F. 安全與權限
- [ ] F1 所有 flows 執行與歷史 API 需登入，並驗證 runId 屬於當前 userId。
- [ ] F2 `/flows` 列表公開但僅顯示 visibility=public。
- [ ] F3 `/flows/[slug]` 與 `/flows/[slug]/history` 需登入；伺服器端保護路由。

## G. 觀測性與維運
- [ ] G1 在伺服器紀錄每步耗時與錯誤（flow_run_steps.durationMs / error）。
- [ ] G2 以簡單日誌/sonner 通知前端執行階段狀態。

## H. 相容性與過渡
- [ ] H1 保留現有首頁 6 卡舊流程與 stage1~4 API，不互相干擾。
- [ ] H2 後續可選擇將首頁改為讀取 `flows.json` 以單一來源。

## I. 驗收要點（Quality Gates）
- [ ] I1 以假資料驗證：缺引用、越級引用、未知 type → 能被前端/後端阻擋並顯示中文錯誤。
- [ ] I2 以兩次連續執行驗證 run 歷史：R2 key 皆不同、DB 有紀錄、歷史頁可見。
- [ ] I3 權限：A 使用者不可讀/刪 B 使用者的 run；列表頁可見，單頁需登入。
- [ ] I4 產生 API 僅用 JSON 權威參數（不受程式預設覆蓋）。
